# Архитектура "Clean" в Go

Это пример архитектуры "Clean" для Go чтобы продемонстрировать разработку 
приложения пригодного для тестирования, которое может работать на AppEngine 
в Google Cloud Storage или на традиционном хостинге с MongoDB для хранилища 
(но этим не ограничивается).

Сущестувет несколько разных архитектур приложений, которые являются 
вариациаям одного того же - иметь чистое (четкое) разделение обязанностей и зависимостей, что следует рекомендациям "принципа инверсии зависимостей":

A. Высокоуровневые модули не должны зависеть от низкроуровневых. 
Всем следует им зависеть только от абстракций.

B. Абстракции не должны зависеть от подробностей. Подробности не должны зависеть от абстракций. 

Вариации этого подхода включают:

* [The Clean Architecture](https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html) пропагандируется Robert Martin ('Uncle Bob')
* Ports & Adapters or [Hexagonal Architecture](http://alistair.cockburn.us/Hexagonal+architecture) от Alistair Cockburn
* [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) от Jeffrey Palermo

Для более детального глубокого практического применения большинства этих идей
я настоятельно рекомендую  прекрасную книгу [Implementing Domain-Driven Design](http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)
от Vaughn Vernon который описывает все очень детеально.

Кроме чистой кодовой базы, подходы предлагают также другие преимущества - 
значительные части системы могут быть подвергнуты модульному тестированию быстро
и просто без разворачивания полного набора средств веб-технологий, это часто сложно, когда зависимости построены неправильно (если вам нужна рабочая база данных и веб-сервер, чтобы запустит ваши тесты - вы делаете это неверно).

Я исользовал это ранее в мире .NET, но позабыл полсе перехода на Python. 
После очередной смены языка (да снова), как я попал в прекрасный мир go, 
я наткнулся на статью вновь воспламинившую мой интерес в этом:
[Applying The Clean Architecture to Go applications](http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/)

Ее замечатльно читать, но мне показалось пример чуток переусложнен и сфокусирован на частях модели реляционной базы данных и в тоже время она была недостаточно 
подробна в некоторых вопросах, которые я хотел решить, такие как переключение 
между разными типами хранилищь и веб UI или библиотекой (в Go их достаточно большой выбор!).

Также я искал возможность сделать мое приложение способным работать, 
как самостоятельно, так и в AppEngine, а также обеспечить более легкое тестирование, так что это показалось мне отличной возможностью сделать
что-то экспериментальное и это то к чему я пришел как к прототипу, который 
я надеюсь упростил для демонстрации методов.

## Кольца зависимости

Все мы слышали про многоуровневую или многослойную архитектуру, особенно
если вы пришли из мира .NET или Java, и это несправедливо, что она имеет плохую репутацию. Вероятно потому что часто она настолько слабо реализована с типичной
ошибкой, когда все возложено на слой базы данных внизу, что делает программное 
обеспечение жестким, трудным для тестирования и тесно связанным с реализацей базы
даннх её производителя (неудивительно, что они пропагандируют это так упорно).
 
Инвертирование зависимостей имеет замечательный эффект преобразования 
для вашего кода. Далее мое представление слоев или колец реализованных на языке
Go (или 'Golang' в Google).

### Домен

В центре зависимосте - домен. Они - это бизнет объекты или сущности и должны
представлять и включать основополагающие бизнес правила, такие как
"может ли отключенная учетная запись покупателя создать новый заказ?". Обычно присутствует один корневой объект, предсавляющий систему с методами
фабриками для создания других объектов (который в свою очередь может иметь 
свои методы для создания других объектов).
Тут и жиивет ориентированный на логику (домен проблем) архитектура.

Изучение этого должно дать вам понимание бизнес модели для приложения и с чем 
работает система. Этот пакет дает возможность писать код для модульных тестов 
для проверки основых частей приложения, чтобы убедиться в соблюдении простых 
(базовых) правил.

### Движок / Сценарии (Engine / Use-Cases)

Уровень приложения и сценариев управляет доменной моделью и добавляет более полные
проаила и логику, включая хранение во внешней памяти. Я предпочитаю термин 
"движок" (engine) для этого пакета, потому что это движок того что приложения 
фактически делает. Правила реализованные на данном уровне не должны затрагивать 
правила доменной модели, но очевидно могут зависить от них. Правила приложения
также не должны полагастья на используемые UI или библиотеки хранения 
во внешней памяти.

Почему бы бизнес правила должны меняться от того какая UI библиотека сейчас
в моде в этом месяце или мы хотим сменить РСУБД на MongoDB или какое-либо 
облачное хранилище данных?
Это подробности реализации, которые тянут рычаги в сценариях или используеются
движком через абстрактные интерфейсы.

### Адаптеры интерфейсов (Interface Adapters)

Это касается перобразования данных из формы, в которой сценариии передают их 
каким-либо внешним библиотекам или драверам для использования
Сценайри может ожидать структуру-запрос с набором параметров и возвращать 
струрктуру-ответю
Публичная часть приложения более вероястно ожидает отправки запросов в JSON или 
HTTP FORM POST и возвращает JSON или подготовленный HTML. База данных может
возвращать результаты в структуре, которую необходмо адаптировать, чтобы остальные
части приложения могли использовать ее.


### Библиотеки и драйверы (Frameworks and Drivers)

Есть порты, которые позволяют системе общаться с 'внешними ресурсам', это могут
быть базы данных для хранения данных или веб-сервер для интерфейса пользователя
(UI). Внутренние сценарии и доменные сущности ничего не дожын знать о реализации
этих слоев и они могут меняться со временем потому что...ну, мы хранили данные в SQL, затем в MongoDB и теперь в облачном хранилище. Смена хранилища не должна менять приложение или бизнес логику. Имею склонность называть это "providers" из-за ...  что ж, .NET.

## Запуск

В папке `app` ...

### App Engine

Установить AppEngine SDK for Go:

    goapp serve

### Отдельное приложение

Установить и запустить mongodb, собрать и запустить go приложение как обычно:

    mongod --config /usr/local/etc/mongod.conf
    go run app.go

### Запуск тестов

Не добавлено еще

    ginkgo watch -cover domain
    go tool cover -html=domain/domain.coverprofile

## Заметки по реализации

### Метки сборки

Go имеет метки сборки для управления включением кода и когда используется запуск 
в AppEngine, тогда тег  `appengine` автоматически применяется. Это дает 
простой способ включить или исключить код, который работает на одной или другой 
платформе, т.е нет нужны делать провайдер для appengine в отделной сборке и часть
кода не может исполняться в appengine classic - это дает способ держать вещи
раздельно.

### Внедрение зависимости (Dependency Injection)

Действительно ли это нужно? Неа. Хотя DI может быть полезным средством, часто
оно берет верх над проектом и становиться запутанной частью притворства
приложения базовой библиотекой (framework). Серьезно, у вас нет нужды в этом и это часто приводить к огрмной стоимости, говоря о сложность и производительности в работе.
Все что делает библиотека внедрения зависимостей вы можете сделать сами с 
несколькими фабриками - то что мы использовали ранее пока мир не DI-помешанным и 
стал думать что Spring было отличной идеей (ох, как мы теперь смеемся над этим).

### Запрос (Query)

Запрос (Query) предоставляет способ передавть определение запроса провайдеру в 
назависимой от языка запросов хранилища форме. Была попытка жтого в .NET с Linq
в смешанных результатах - часто завершается программированием под специфику 
определенной БЛ (обычно SQL server), но в этом случаее язык запросов, гораздо 
проще и создатн более легким, так как ему нужно предоставить только возможность фильтрации для того что будет NoSQL или SQL базой данных испольуемой нереляционным способом.

### Провайдеры к хранилищам данных (Storage providers)

Выбрал AppEngine Datastore и MongoDB ибо похожи они и оба NoSQL хранилища, но 
очень отличаются в том как соединения с состояния управляются. MongoDB 
имеет соединение передавемое через фабрику при инициализации фабрики. AppEngine
Datastore не имеет постоянного соединения и использует контекст из кажого запроса.

### Улучшения

Многое еще упущено. Некоторые очевидыне вещи: нужно передавть в стандартной структуре вставленной в каждый запрос обработчика информацию о 
запросе (аутентифицированный пользователь, IP откуда запроса и др.). Ответы
также должны возвращать ошибки, которые адаптер веб-интерфейса сможет использовать в ответе.

Адаптер для консольного приложени я может быть создан для показа возможности
использовать логику движка приложения и хранилища без веб-интерфейса. 
Некоторые модульные тесты могли бы показать как большая часть часть системы
может быть протестировани без запуска веб-сервера и БД. Тестовые хранилища могут
быть использованы для провери движка и проверка экземпляров движка может помочь в тестах веб-обработчиков. 

### Что с импортами?

Почему я разделяю импорты в Go? Просто нравиться ... Я делю импорты на:

Стандартные пакеты (например `strings`, `fmt`)

Расширения к пакетам (например `net/http`, `encoding/json`)

Сторонние пакеты (например `google.golang.org/appengine/datastore`)

Пакеты приложения (например `github.com/captaincodeman/clean-go/domain`)